#+title: Properties of Sets
#+author: James Leslie
#+STARTUP: noindent hideblocks latexpreview
* Prelude
#+begin_src agda2
{-# OPTIONS --without-K #-}
module UniAgda-new.Core.SetsAndLogic.Sets where

open import UniAgda-new.Core.Types.Everything
open import UniAgda-new.Core.PathAlgebra
open import UniAgda-new.Core.Homotopy
open import UniAgda-new.Core.Equivalences
open import UniAgda-new.Core.SetsAndLogic.ContPropSet1Type
open import UniAgda-new.Core.PathSpaces.Everything
open import UniAgda-new.Core.Axioms

open import UniAgda-new.Core.SetsAndLogic.Props
#+end_src
* Products of sets are sets
The product of two sets is also a set.
#+name: Example 3.1.5
#+begin_src agda2
private
  path-prod-equiv-to-id : {i j : Level} {A : Type i} {B : Type j}
                   (x y : A × B)
                   → (x ≡ y) ≡ ((pr₁ x ≡ pr₁ y) × (pr₂ x ≡ pr₂ y))
  path-prod-equiv-to-id x y = ua path-prod-equiv

prod-of-sets-is-set : ∀ {i j} {A : Type i} {B : Type j}
                      → (isSet A) → (isSet B)
                      → (isSet (A × B))
prod-of-sets-is-set H₁ H₂ x y = transport (λ X → (p q : X) → p ≡ q) (path-prod-equiv-to-id x y ^) λ { (a , b) (a' , b') → path-equiv-prod (H₁ (pr₁ x) (pr₁ y) a a' , H₂ (pr₂ x) (pr₂ y) b b')}
#+end_src
* Function types between sets are sets
#+name: Example3.1.6
#+begin_src agda2
private
  funextD-to-id : {i j : Level} {A : Type i} {B : A → Type j} {f g : (x : A) → B x}
                 → (f ≡ g) ≡ (f ~ g)
  funextD-to-id = ua funextD-equiv

fibs-are-sets-PI-is-set : ∀ {i j} {A : Type i} {B : A → Type j}
                          → ((x : A) → (isSet (B x)))
                          → (isSet ((x : A) → B x))
fibs-are-sets-PI-is-set H f g = transport (λ Z → (p q : Z) → p ≡ q) (funextD-to-id ^) λ { p q → funextD λ x → H x _ _ _ _}


func-of-sets-is-set : ∀ {i j} {A : Type i} {B : Type j}
                      → (isSet B)
                      → (isSet (A → B))
func-of-sets-is-set H f g = transport (λ X → (p q : X) → p ≡ q) (funextD-to-id ^) λ { p q → funextD λ x → H (f x) (g x) (p x) (q x)}
#+end_src
* Sets are 1-Types
#+name: Lemma3.1.8
#+begin_src agda2
private
  helper : ∀ {i} {A : Type i}
           → (f : isSet {i} A) → (x y : A) → (p q q' : x ≡ y) → (r : q ≡ q')
           → (f x y p q) ∘ r ≡ f x y p q'
  helper f x y p q q' r = (lemma2-11-2i _ r (f x y p q) ^ ) ∘ apD (λ q → f x y p q) r


sets-are-1types : ∀ {i} {A : Type i}
                  → isSet {i} A → is1type {i} A
sets-are-1types f x y p q r s = pq=r-to-q=p^r (f x y p p) r (f x y p q) (helper f x y p p q r) ∘ (pq=r-to-q=p^r (f x y p p) s (f x y p q) (helper f x y p p q s)) ^
#+end_src  
* Results
#+begin_src agda2
isSet-is-prop : {i : Level}
                (A : Type i)
                → isProp (isSet A)
isSet-is-prop A f g = funextD λ {x → funextD λ x₁ → funextD λ x₂ → funextD λ x₃ → sets-are-1types f _ _ _ _ _ _}
#+end_src

Being a set is preserved by equivalence.
#+begin_src agda2
equiv-with-set : ∀ {i j} {A : Type i} {B : Type j}
                 → A ≃ B → isSet A
                 → isSet B
equiv-with-set (f , g , α , β , γ) F x y =
  equiv-with-prop {_} {_} {g x ≡ g y} {x ≡ y}
    (((ap g) ,
      (thm2-11-1 (isequiv-adjointify (f , (α , β))))) ^ᵉ)
    (F (g x) (g y))
#+end_src

If a type family has fibres valued in props and comes from a set, the total space is a set.
#+begin_src agda2
prop-fibres-totalspace-set : ∀ {i j} {A : Type i} {P : A → Type j}
                             → isSet A → ((a : A) → isProp (P a))
                             → isSet (Σ[ a ∈ A ] (P a))
prop-fibres-totalspace-set {i} {j} {A} {P} H f (a , X) (b , Y) =
  equiv-with-prop
  (thm2-7-2 ^ᵉ)
  (λ { (p , p') (q , q') →
    path-equiv-sigma
      ((H _ _ _ _) ,
      (props-are-sets (f b) _ _ _ _))})
#+end_src

* Unit is a set
The unit type is a set.
#+name: Example3.1.2
#+begin_src agda2
unit-is-set : isSet Unit
unit-is-set x y =
  transport (λ X → (p q : X) → p ≡ q) (ua (thm2-8-1 x y) ^) λ { tt tt → refl}
ex3-1-2 = unit-is-set
#+end_src  
* Empty is a set
The empty type is a set
#+name: Example3.1.3
#+begin_src agda2
empty-is-set : isSet Empty
empty-is-set () y
#+end_src
* The natural numbers are a set
The natural numbers are a set, as their path space is either contractible or empty.
#+name: Example3.1.4  
#+begin_src agda2
private
  nat-equiv-to-id : (m n : ℕ) → (m ≡ n) ≡ nat-code m n
  nat-equiv-to-id m n = ua {_} {_} {_} (thm2-13-1 m n)


ℕ-is-set : isSet ℕ
ℕ-is-set zero zero = transport (λ X → (p q : X) → p ≡ q) (nat-equiv-to-id zero zero ^) λ { tt tt → refl}
ℕ-is-set zero (suc n) = transport (λ X → (p q : X) → p ≡ q) (nat-equiv-to-id zero (suc n) ^) λ { () q}
ℕ-is-set (suc m) zero = transport (λ X → (p q : X) → p ≡ q) (nat-equiv-to-id (suc m) zero ^) λ { () q}
ℕ-is-set (suc m) (suc n) = transport (λ X → (p q : X) → p ≡ q) (nat-equiv-to-id (suc m) (suc n) ^) (transport (λ X → (p q : X) → p ≡ q) (nat-equiv-to-id m n) (ℕ-is-set m n))
#+end_src
