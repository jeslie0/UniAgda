#+title: Functors
#+author: James Leslie
#+description: Functors and their some properties
#+STARTUP: hideblocks
* Prelude
#+begin_src agda2
{-# OPTIONS --without-K  #-}
module UniAgda.categories.functor where
open import UniAgda.categories.category public
#+end_src
* Definition
We introduce functors between precategories as a record, giving the sigma type and equivalence later.
#+begin_src agda2
record Functor {i j k l} (A : Precategory i j) (B : Precategory k l) : Type (i ⊔ j ⊔ k ⊔ l) where
  eta-equality
  open Precategory
  field
    F-ob : A .ob → B .ob
    F-hom : {a b : A .ob} → A [ a , b ] →  B [ (F-ob a) , (F-ob b) ]
    F-id : {a : A .ob} → F-hom (A .Id {a}) ≡ (B .Id {F-ob a})
    F-nat : {a b c : A .ob} (g : A [ b , c ]) (f : A [ a , b ]) → F-hom (g o⟨ A ⟩ f) ≡ (F-hom g) o⟨ B ⟩ (F-hom f)
#+end_src
** Sigma definition and equivalence
#+begin_src agda2
Functor-sig : ∀ {i j k l}
          (A : Precategory i j) (B : Precategory k l)
          → Type (i ⊔ j ⊔ k ⊔ l)
Functor-sig {i} {j} {k} {l} A B =
  let module A = Precategory A in
    let module B = Precategory B in
      Σ[ F-ob ∈ ((A.ob) → (B.ob))] (
        Σ[ F-hom ∈ ({a b : A.ob} → A.hom a b → B.hom (F-ob a) (F-ob b))] (
          Σ[ F-id ∈ ({a : A.ob} → F-hom (A.Id {a}) ≡ (B.Id {F-ob a}))] (
            ({a b c : A.ob} (g : A.hom b c) (f : A.hom a b) → F-hom (A.comp g f) ≡ B.comp (F-hom g) (F-hom f)))))

functor-sig→rec : ∀ {i j k l}
                  (A : Precategory i j) (B : Precategory k l)
                  → Functor-sig A B → Functor A B
functor-sig→rec A B (F-ob , F-hom , F-id , F-nat) =
  record { F-ob = F-ob ; F-hom = F-hom ; F-id = F-id ; F-nat = F-nat }

functor-rec→sig : ∀ {i j k l}
                  (A : Precategory i j) (B : Precategory k l)
                  → Functor A B → Functor-sig A B
functor-rec→sig A B record { F-ob = F-ob ; F-hom = F-hom ; F-id = F-id ; F-nat = F-nat } =
  (F-ob ,
  F-hom ,
  F-id ,
  F-nat)

functor-rec→sig→rec : ∀ {i j k l}
                      (A : Precategory i j) (B : Precategory k l)
                      → (F : Functor A B) → (functor-sig→rec A B o functor-rec→sig A B) F ≡ F
functor-rec→sig→rec A B F = refl

functor-sig→rec→sig : ∀ {i j k l}
                      (A : Precategory i j) (B : Precategory k l)
                      → (F : Functor-sig A B) → (functor-rec→sig A B o functor-sig→rec A B) F ≡ F
functor-sig→rec→sig A B (F-ob , F-hom , F-id , F-nat) =
  path-equiv-sigma (refl ,
    (path-equiv-sigma (refl ,
      (path-equiv-sigma (refl ,
        refl)))))

Functor-sig-Equiv : ∀ {i j k l}
                    (A : Precategory i j) (B : Precategory k l)
                    → Functor-sig A B ≃ Functor A B
Functor-sig-Equiv A B = equiv-adjointify
  (functor-sig→rec A B ,
  functor-rec→sig A B ,
  functor-rec→sig→rec A B ,
  functor-sig→rec→sig A B)
#+end_src

#+begin_src agda2
open Functor
#+end_src
* Functor composition
#+begin_src agda2
-- compᶠ : ∀ {i₁ i₂ i₃ i₄ i₅ i₆} {A : Precategory i₁ i₂} {B : Precategory i₃ i₄} {C : Precategory i₅ i₆}
--           (G : Functor B C) (F : Functor A B)
--           → Functor A C
-- F-ob (compᶠ G F) = G .F-ob o F .F-ob
-- F-hom (compᶠ G F) = G .F-hom o F .F-hom
-- F-id (compᶠ G F) = {!!}
-- F-nat (compᶠ G F) = {!!}
#+end_src
* Identity functor
#+begin_src agda2
Idᶠ : ∀ {i j} {C : Precategory i j}
      → Functor C C
F-ob (Idᶠ {i} {j} {C}) = id
F-hom (Idᶠ {i} {j} {C}) = id
F-id (Idᶠ {i} {j} {C}) = refl
F-nat (Idᶠ {i} {j} {C}) g f = refl
#+end_src

