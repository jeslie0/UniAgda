#+title: Natural Transformations
#+author: James Leslie
#+STARTUP: hideblocks
* Prelude
  #+begin_src agda2
{-# OPTIONS --without-K #-}
module UniAgda.e-cat.natural-transformation where

open import UniAgda.e-cat.functor public
open Precategory
open Functor
#+end_src
* Natural transformations
A natural transformation is a map between functors. We define it as a record.
#+begin_src agda2
record Nat-trans {i j k l : Level} {A : Precategory i j} {B : Precategory k l} (F G : Functor A B) : Type (i ⊔ j ⊔ l) where
  eta-equality
  open Precategory
  open Functor
  field
    α-ob : (x : A .ob) → B .hom (F .F-ob x) (G .F-ob x)
    α-hom : {x y : A .ob} (f : A [ x , y ]) → (α-ob y) o⟨ B ⟩ (F .F-hom f) ≡ (Functor.F-hom G f) o⟨ B ⟩ (α-ob x)
#+end_src

As precategories have sets of morphisms, the hom condition is a proposition. We use this later to show that there is a set of natural transformations between two functors.
#+begin_src agda2
  α-hom-is-prop : {x y : A .ob} → isProp ((f : Precategory.hom A x y) → Precategory.comp B (α-ob y) (Functor.F-hom F f) ≡ Precategory.comp B (Functor.F-hom G f) (α-ob x))
  α-hom-is-prop = prop-fibres-Pi-is-prop λ f₁ → sets-have-prop-ids _ (B .hom-set _ _) _ _
#+end_src

** Sigma definition and equivalence
The Σ definition of a natural transformation is presented here.
#+begin_src agda2
Nat-trans-sig : {i j k l : Level} {A : Precategory i j} {B : Precategory k l}
            (F G : Functor A B)
            → Type (i ⊔ j ⊔ l)
Nat-trans-sig {i} {j} {k} {l} {A} {B} F G =
  let module A = Precategory A in
  let module B = Precategory B in
  let module F = Functor F in
  let module G = Functor G in
    Σ[ α-ob ∈ ((x : A.ob) → B.hom (F.F-ob x) (G.F-ob x)) ] (
    {x y : A.ob} (f : A.hom x y) → B.comp (α-ob y) (F.F-hom f) ≡ B.comp (G.F-hom f) (α-ob x))
#+end_src

Of course, we have an equivalence between the two definitions.
#+begin_src agda2
nat-trans-sig→rec : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
                     (F G : Functor A B)
                     → Nat-trans-sig F G → Nat-trans F G
Nat-trans.α-ob (nat-trans-sig→rec F G (α₁ , α₂)) = α₁
Nat-trans.α-hom (nat-trans-sig→rec F G (α₁ , α₂)) = α₂

nat-trans-rec→sig : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
                       (F G : Functor A B)
                       → Nat-trans F G → Nat-trans-sig F G
nat-trans-rec→sig F G record { α-ob = α-ob ; α-hom = α-hom } =
  α-ob ,
  α-hom

nat-trans-rec→sig→rec : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
                 (F G : Functor A B)
                 → (α : Nat-trans F G) → (nat-trans-sig→rec F G o nat-trans-rec→sig F G) α ≡ α
nat-trans-rec→sig→rec F G α = refl

nat-trans-sig→rec→sig : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
                 (F G : Functor A B)
                 → (α : Nat-trans-sig F G) → (nat-trans-rec→sig F G o nat-trans-sig→rec F G) α ≡ α
nat-trans-sig→rec→sig F G (a , b) = path-equiv-sigma
  (refl , refl)

Nat-trans-sig-equiv : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
               (F G : Functor A B)
               → (Nat-trans-sig F G) ≃ (Nat-trans F G)
Nat-trans-sig-equiv F G = equiv-adjointify
  (nat-trans-sig→rec F G ,
  (nat-trans-rec→sig F G) ,
  (nat-trans-rec→sig→rec F G) ,
  (nat-trans-sig→rec→sig F G))
#+end_src

#+begin_src agda2
open Nat-trans
#+end_src


* Natural transformations properties
As natural transformations have a prop as their second piece of data, we only need to consider what two natural transformations do on objects, to see if they are equal or not.
#+begin_src agda2
nat-trans-id : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
               {F G : Functor A B} (α β : Nat-trans F G)
               → (α .α-ob ≡ β .α-ob) → α ≡ β
nat-trans-id {i} {j} {k} {l} {A} {B} {F} {G} α β p =
  equiv-types-eq α β (Nat-trans-sig-equiv F G)
    (fibres-props-eq
      (λ T X Y → implicit-funext λ a →
        implicit-funext λ b →
          funextD λ f → B .hom-set _ _ _ _ (X f) (Y f))
      ((α .α-ob) , (α .α-hom))
      ((β .α-ob) , (β .α-hom))
      p)
#+end_src

As previously mentioned, the type of natural transformations between two functors is a set.
#+begin_src agda2
Nat-trans-is-set : {i j k l : Level} {A : Precategory i j} {B : Precategory k l}
                      (F G : Functor A B)
                      → isSet (Nat-trans F G)
Nat-trans-is-set {A = A} {B = B} F G = equiv-with-set (Nat-trans-sig-equiv F G)
  (prop-fibres-totalspace-set
    (fibs-are-sets-PI-is-set (λ x → B .hom-set (F .F-ob x) (G . F-ob x)))
    λ a P Q → implicit-funext
      λ x → implicit-funext
      λ y → funextD λ f → sets-have-prop-ids _ (B .hom-set (F .F-ob x) (G . F-ob y)) _ _ (P f) (Q f))
#+end_src

* Categorical properties
We prove some useful results which will be used to show that functors form a category. Firstly, there is an identity natural transformation.
#+begin_src agda2
idⁿ : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l} {F : Functor A B}
      → Nat-trans F F
idⁿ {i} {j} {k} {l} {A} {B} {F} =
  record { α-ob = λ x → B .Id ;
           α-hom = λ f → B .IdR (F .F-hom f) ∘ B .IdL (F .F-hom f) ^ }
#+end_src

We also have (vertical) composition of natural transformations.
#+begin_src agda2
nat-trans-compᵛ : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l} {F G H : Functor A B}
                  (β : Nat-trans G H) (α : Nat-trans F G)
                  → Nat-trans F H
nat-trans-compᵛ {i} {j} {k} {l} {A} {B} {F} {G} {H}
  record { α-ob = β₁ ; α-hom = β₂ }
  record { α-ob = α₁ ; α-hom = α₂ } =
    record { α-ob = (λ a → (β₁ a) o⟨ B ⟩ (α₁ a)) ;
             α-hom = λ { {x} {y} f → B .Assoc (F .F-hom f) (α₁ y) (β₁ y) ^ ∘
               precat-whiskerL B (α₂ f) (β₁ y) ∘
               B .Assoc (α₁ x) (G .F-hom f) (β₁ y) ∘
               precat-whiskerR B (β₂ f) (α₁ x) ∘
               B .Assoc (α₁ x) (β₁ x) (H .F-hom f) ^} }
#+end_src

Composing with the identity is as expected.
#+begin_src agda2
nat-trans-id-compᵛ : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
                     (F G : Functor A B) (α : Nat-trans F G)
                     → nat-trans-compᵛ idⁿ α ≡ α
nat-trans-id-compᵛ {B = B} F G record { α-ob = α₁ ; α-hom = α₂ } =
  nat-trans-id _ _ (funextD λ x → B .IdR (α₁ x))


nat-trans-compᵛ-id : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l}
                     (F G : Functor A B) (α : Nat-trans F G)
                     → nat-trans-compᵛ  α idⁿ ≡ α
nat-trans-compᵛ-id {B = B} F G record { α-ob = α₁ ; α-hom = α₂ } =
  nat-trans-id _ _ (funextD λ x → B .IdL (α₁ x))
#+end_src

Finally, composition is associative.
#+begin_src agda2
nat-trans-comp-assoc : ∀ {i j k l} {A : Precategory i j} {B : Precategory k l} {F G H K : Functor A B}
                       (α : Nat-trans F G) (β : Nat-trans G H) (γ : Nat-trans H K)
                     → nat-trans-compᵛ γ (nat-trans-compᵛ β α) ≡ nat-trans-compᵛ (nat-trans-compᵛ γ β) α
nat-trans-comp-assoc {B = B}
  record { α-ob = α₁ ; α-hom = α₂ }
  record { α-ob = β₁ ; α-hom = β₂ }
  record { α-ob = γ₁ ; α-hom = γ₂ } =
    nat-trans-id _ _
      (funextD λ x → B .Assoc (α₁ x) (β₁ x) (γ₁ x))
#+end_src
